<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Fretboard Trainer</title>
    <style>
        /* --- CSS VARIABLES --- */
        :root {
            --bg-color: #f0f2f5;
            --text-color: #1a1a1a;
            --panel-bg: #ffffff;
            --panel-shadow: rgba(0,0,0,0.1);
            --fretboard-bg: #3d2616;
            --fretboard-border: #1a1008;
            --string-color: #a3a3a3;
            --fret-wire: #bdafa6;
            --nut-color: #e5e5e5; 
            --marker-color: #e5e5e5;
            --highlight-blue: #2563eb;
            --highlight-orange: #ea580c;
            --theory-bg: #fefce8;
            --theory-border: #eab308;
            --theory-text: #422006;
            --cof-ring-color: #e0e0e0;
            --cof-wedge-bg: #f7f7f7;
            --cof-border: #4a4a4a;
            --timer-color: #dc2626;
            --stats-bg: #ccfbf1; /* Very Light Teal for HUD item background */
            --stats-border: #06b6d4;
        }

        body.dark-mode {
            --bg-color: #111827;
            --text-color: #f3f4f6;
            --panel-bg: #1f2937;
            --panel-shadow: rgba(0,0,0,0.5);
            --fretboard-bg: #291810;
            --fretboard-border: #000000;
            --string-color: #6b7280;
            --fret-wire: #6b7280;
            --nut-color: #4b5563; 
            --marker-color: #9ca3af;
            --theory-bg: #422006;
            --theory-border: #a16207;
            --theory-text: #fefce8;
            --cof-ring-color: #374151;
            --cof-wedge-bg: #2d3748;
            --cof-border: #9ca3af;
            --timer-color: #ef4444;
            --stats-bg: #0f172a; 
            --stats-border: #06b6d4;
        }

        /* --- CORE LAYOUT --- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            text-align: center;
            transition: background-color 0.3s, color 0.3s;
        }

        h1 { margin-bottom: 5px; font-size: 2.5rem; letter-spacing: 1px; }

        /* --- CONTROLS CONTAINER --- */
        .controls-wrapper {
            background: var(--panel-bg);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 6px var(--panel-shadow);
            margin-bottom: 20px;
            display: inline-block;
            max-width: 1200px;
            width: 95%;
        }

        .controls-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
            padding: 10px 0;
            border-top: 2px solid var(--fret-wire);
        }

        .controls-group.quiz-modes { border-top: none; margin-top: 0; }
        .controls-group.settings-tools { justify-content: space-around; padding-top: 15px; }

        .setting-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            padding: 8px;
            border: 1px solid var(--fretboard-border);
            border-radius: 8px;
            background-color: var(--bg-color);
            color: var(--text-color);
            flex-grow: 1; 
            min-width: 150px;
        }
        .setting-group.full-width { min-width: 100%; }

        .checkbox-group, .radio-group { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 5px; }
        
        select {
            padding: 10px; font-size: 1.1em; border-radius: 8px;
            border: 2px solid #3b82f6; background-color: var(--panel-bg);
            color: var(--text-color); font-weight: bold; cursor: pointer;
        }
        
        /* --- BUTTONS --- */
        button {
            padding: 15px 25px; font-size: 1.1em; font-weight: 800; cursor: pointer;
            border: none; border-radius: 8px; background-color: #3b82f6; color: white;
            transition: all 0.2s; box-shadow: 0 4px 0 #1d4ed8;
        }
        button:active { transform: translateY(4px); box-shadow: none; }
        button:hover { filter: brightness(110%); }

        /* Specific Button Colors */
        #theme-toggle { background-color: #94a3b8; box-shadow: 0 4px 0 #475569; padding: 10px 15px; }
        #free-play-btn { background-color: #10b981; box-shadow: 0 4px 0 #047857; } 
        #cof-quiz-btn { background-color: #f59e0b; box-shadow: 0 4px 0 #d97706; } 
        #name-note-btn { background-color: #14b8a6; box-shadow: 0 4px 0 #0f766e; }
        #clear-board-btn { background-color: #dc2626; box-shadow: 0 4px 0 #991b1b; } 
        #replay-btn { background-color: #8b5cf6; box-shadow: 0 4px 0 #7c3aed; }
        #hint-mode-toggle { background-color: #64748b; box-shadow: 0 4px 0 #334155; }
        #hint-mode-toggle.active { background-color: #9333ea; box-shadow: 0 4px 0 #6b21a8; }
        #next-question { background-color: #0f172a; box-shadow: 0 4px 0 #000; min-width: 200px; font-size: 1.3em;}
        #reset-stats-btn { background-color: #f97316; box-shadow: 0 4px 0 #c2410c; padding: 10px 15px; font-size: 1em; margin-top: 10px;}

        /* --- QUESTION AREA --- */
        #target-note-display {
            font-size: 5em; font-weight: 900; min-height: 1.2em; 
            display: flex; justify-content: center; align-items: center;
            margin: 10px 0; color: var(--text-color); 
            text-shadow: 2px 2px 0px var(--panel-shadow);
        }
        
        #message-display {
            font-size: 1.3em; font-weight: bold; min-height: 1.5em; 
            margin: 5px 0 20px 0; color: #6b7280;
        }

        /* --- ACTION BAR (HUD) --- */
        #action-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 10px auto 30px auto;
            padding: 15px;
            background-color: var(--panel-bg);
            border-radius: 12px;
            box-shadow: 0 2px 4px var(--panel-shadow);
            max-width: 1100px; /* Wider to accommodate stats */
        }

        .hud-item {
            font-size: 1.5em;
            font-weight: 900;
            color: var(--text-color);
            background: var(--bg-color);
            padding: 10px 20px;
            border-radius: 8px;
            border: 1px solid var(--fretboard-border);
            white-space: nowrap;
        }
        
        .stat-hud-item {
            font-size: 1.1em; /* Smaller font for stats to fit multiple */
            font-weight: 700;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 15px;
            background: var(--stats-bg); /* Highlight stats background */
            border: 2px solid var(--stats-border);
            border-radius: 8px;
        }
        
        .stat-value {
            font-size: 1.5em;
            font-weight: 900;
            color: var(--highlight-blue);
        }

        #timer-display {
            color: var(--timer-color);
            font-size: 2em;
            font-weight: 900;
            min-width: 60px;
            text-align: center;
        }

        /* --- MULTIPLE CHOICE PANEL --- */
        #mc-options {
            display: none; justify-content: center; gap: 15px;
            padding: 0 0 20px 0; margin: 0 auto; max-width: 900px;
        }

        .mc-button {
            flex-grow: 1; padding: 25px 10px; font-size: 2em; font-weight: 900;
            border-radius: 12px; box-shadow: 0 6px 0 var(--fretboard-bg);
            background-color: var(--fret-wire); color: var(--text-color);
            min-width: 100px;
        }
        .mc-button:active { transform: translateY(6px); box-shadow: none; }
        .mc-button.correct-answer { background-color: var(--highlight-blue); color: white; }
        .mc-button.wrong-answer { background-color: var(--highlight-orange); color: white; }
        .mc-button.revealed-answer { background-color: #10b981; color: white; }

        /* --- FRETBOARD --- */
        #fretboard-wrapper {
            display: flex; justify-content: center; margin-top: 10px;
            overflow-x: auto; padding-bottom: 20px;
        }

        #fretboard-container {
            background-color: var(--fretboard-bg);
            border: 6px solid var(--fretboard-border);
            padding: 0; border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            display: inline-block; position: relative;
        }
        
        #fretboard { display: grid; grid-auto-flow: column; white-space: nowrap; }

        .fret-column { display: grid; grid-template-rows: repeat(6, 50px); width: 55px; border-right: 3px solid var(--fret-wire); position: relative; }
        .nut-column { width: 40px; background-color: var(--nut-color); border-right: 6px solid #666; display: grid; grid-template-rows: repeat(6, 50px); }
        .marker { position: absolute; background-color: var(--marker-color); border-radius: 50%; z-index: 1; left: 50%; transform: translateX(-50%); pointer-events: none; }
        .single-marker { width: 18px; height: 18px; top: 150px; margin-top: -9px; }
        .double-marker-top { width: 18px; height: 18px; top: 75px; margin-top: -9px; }
        .double-marker-bottom { width: 18px; height: 18px; top: 225px; margin-top: -9px; }
        
        .string-cell { width: 100%; height: 50px; display: flex; justify-content: center; align-items: center; position: relative; box-sizing: border-box; border-bottom: 1px solid rgba(0,0,0,0.2); }
        .string-line { position: absolute; top: 50%; left: 0; right: 0; background-color: var(--string-color); transform: translateY(-50%); z-index: 2; box-shadow: 0 1px 2px rgba(0,0,0,0.5); }
        .string-0 { height: 1.5px; } .string-1 { height: 2px; } .string-2 { height: 2.5px; } .string-3 { height: 3px; } .string-4 { height: 4px; } .string-5 { height: 5px; } 
        
        .note-spot { width: 40px; height: 40px; background-color: transparent; border-radius: 50%; position: relative; z-index: 10; cursor: pointer; display: flex; justify-content: center; align-items: center; font-size: 1.2em; font-weight: 900; color: white; border: 2px solid transparent; transition: transform 0.1s; }
        .nut-column .note-spot { color: var(--text-color); text-shadow: none; }
        .note-spot:hover { background-color: rgba(255,255,255,0.2); transform: scale(1.15); }
        
        .correct { background-color: var(--highlight-blue) !important; border: 3px solid white; box-shadow: 0 0 15px var(--highlight-blue); }
        .correct::after { content: '‚úì'; }
        .incorrect { background-color: var(--highlight-orange) !important; border: 3px solid white; }
        .incorrect::after { content: '‚úï'; }
        .revealed { background-color: #facc15 !important; color: black !important; border: 2px solid black; }
        .sequence-correct { background-color: #9333ea !important; border: 2px solid white; }
        .hint-mode-on { background-color: #475569; color: white; opacity: 1; border: 1px solid #94a3b8; }
        .target-note { background-color: #db2777 !important; border: 3px solid white; box-shadow: 0 0 15px #db2777; }
        .highlighted-question { background-color: #db2777 !important; border: 3px solid white; box-shadow: 0 0 15px #db2777; color: white !important; }

        /* --- COF --- */
        #cof-wrapper { display: none; justify-content: center; margin: 40px auto; max-width: 600px; }
        .cof-ring { position: relative; width: 400px; height: 400px; border-radius: 50%; background: var(--cof-ring-color); box-shadow: 0 4px 15px var(--panel-shadow); }
        .cof-wedge-container { position: absolute; top: 50%; left: 50%; width: 50%; height: 50%; transform-origin: 0% 0%; overflow: hidden; pointer-events: none; }
        .cof-wedge { position: absolute; width: 200%; height: 200%; top: -100%; left: -100%; transform-origin: 100% 100%; cursor: pointer; pointer-events: auto; background-color: var(--cof-wedge-bg); border-radius: 400px; border: 1px solid var(--cof-border); transition: all 0.15s ease-out; clip-path: polygon(100% 100%, 0% 100%, 100% 0%); }
        .cof-wedge:hover { opacity: 0.9; filter: brightness(1.1); }
        .cof-note-label { position: absolute; font-size: 1.4em; font-weight: 900; color: var(--text-color); top: 25px; left: 25px; transform: rotate(15deg) translate(140px, -10px); transform-origin: 0 0; pointer-events: none; }
        .cof-center { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 150px; height: 150px; background: var(--fretboard-bg); border-radius: 50%; z-index: 20; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.5); font-size: 1.1em; font-weight: bold; color: white; text-align: center; }
        .cof-center-note { font-size: 2em; font-weight: 900; }
        .cof-correct { background-color: var(--highlight-blue) !important; box-shadow: 0 0 5px 3px var(--highlight-blue); }
        .cof-incorrect { background-color: var(--highlight-orange) !important; box-shadow: 0 0 5px 3px var(--highlight-orange); }
        .cof-hint { background-color: #db2777 !important; box-shadow: 0 0 5px 3px #db2777; }
    </style>
</head>
<body>

    <header id="header">
        <h1>Ultimate Fretboard Trainer</h1>
        
        <div class="controls-wrapper">

            <div class="controls-group settings-tools">
                <button id="theme-toggle" onclick="toggleTheme()">‚òÄÔ∏è Theme</button>
                <button id="theory-toggle" onclick="toggleTheory()">üìñ Theory: OFF</button>
                <button id="hint-mode-toggle" onclick="toggleHintMode()">üí° Hints: OFF</button>
            </div>

            <div id="theory-panel" style="display:none">
                <h3 id="theory-title">Theory Lesson</h3>
                <p id="theory-content"></p>
            </div>
            
            <div class="controls-group quiz-modes">
                <button onclick="startQuiz('single')">Find Note</button>
                <button id="name-note-btn" onclick="startQuiz('name')">Name Note</button>
                <button onclick="startQuiz('all')">Find All</button>
                <button onclick="startQuiz('chord')">Chords</button>
                <button onclick="startQuiz('scale')">Scales</button>
                <button id="cof-quiz-btn" onclick="startQuiz('cof')">‚≠ï Circle of Fifths</button>
                <button id="free-play-btn" onclick="startQuiz('free')">üé∏ Free Play</button>
            </div>

            <div class="controls-group settings-filters">
                <div class="setting-group filter-group" id="chord-filters" style="display:none;">
                    <label><strong>Chord Types:</strong></label>
                    <div class="checkbox-group">
                        <input type="checkbox" id="chord_maj" value="Maj" checked><label for="chord_maj">Major</label>
                        <input type="checkbox" id="chord_min" value="Min" checked><label for="chord_min">Minor</label>
                        <input type="checkbox" id="chord_7" value="7" checked><label for="chord_7">Dom 7</label>
                    </div>
                </div>

                <div class="setting-group filter-group" id="scale-filters" style="display:none;">
                    <label><strong>Scale Type:</strong></label>
                    <div class="radio-group">
                        <input type="radio" name="scale_type" id="scale_major" value="Major" checked><label for="scale_major">Major</label>
                        <input type="radio" name="scale_type" id="scale_minor" value="Minor"><label for="scale_minor">Natural Minor</label>
                    </div>
                </div>

                <div class="setting-group filter-group full-width" id="name-note-string-filters" style="display:none;">
                    <label><strong>Name Note Strings (EADGBE):</strong></label>
                    <div class="checkbox-group">
                        <input type="checkbox" id="string_5" data-s="5" checked><label for="string_5">E</label>
                        <input type="checkbox" id="string_4" data-s="4" checked><label for="string_4">A</label>
                        <input type="checkbox" id="string_3" data-s="3" checked><label for="string_3">D</label>
                        <input type="checkbox" id="string_2" data-s="2" checked><label for="string_2">G</label>
                        <input type="checkbox" id="string_1" data-s="1" checked><label for="string_1">B</label>
                        <input type="checkbox" id="string_0" data-s="0" checked><label for="string_0">e</label>
                    </div>
                </div>

                <div class="setting-group filter-group" id="name-note-type-filters" style="display:none;">
                    <label><strong>Name Note Types:</strong></label>
                    <div class="radio-group">
                        <input type="radio" name="note_type_filter" id="note_all" value="all" checked><label for="note_all">All Notes</label>
                        <input type="radio" name="note_type_filter" id="note_naturals" value="naturals"><label for="note_naturals">Naturals (C D E F G A B)</label>
                        <input type="radio" name="note_type_filter" id="note_accidentals" value="accidentals"><label for="note_accidentals">Sharps/Flats</label>
                        <input type="radio" name="note_type_filter" id="note_anchors" value="anchors"><label for="note_anchors">Anchor Frets (3, 5, 7, 9, 12, etc.)</label>
                    </div>
                </div>

                <div class="setting-group">
                    <label><strong>Tuning:</strong></label>
                    <select id="tuning-select" onchange="changeSetting()">
                        <option value="standard">Standard</option>
                        <option value="drop_d">Drop D</option>
                        <option value="dadgad">DADGAD</option>
                        <option value="open_g">Open G</option>
                    </select>
                </div>

                <div class="setting-group">
                    <label><strong>Frets:</strong></label>
                    <select id="range-select" onchange="changeSetting()">
                        <option value="12" selected>0 - 12</option>
                        <option value="24">0 - 24</option>
                    </select>
                </div>

                <div class="setting-group filter-group" id="timer-setting" style="display:none;">
                    <label><strong>Quiz Timer (Seconds):</strong></label>
                    <select id="timer-select" onchange="resetTimer()">
                        <option value="0">Off</option>
                        <option value="5">5s</option>
                        <option value="10">10s</option>
                        <option value="15">15s</option>
                    </select>
                </div>
            </div>
            
             <div style="text-align: center; margin-top: -10px;">
                <button id="reset-stats-btn" onclick="resetStats()">Reset Stats</button>
            </div>
        </div>
    </header>

    <div id="target-note-display">Select a Mode</div>
    <p id="message-display">Choose a quiz type or Free Play.</p>
    
    <div id="action-bar">
        <div class="hud-item">
            Streak: <span id="streak-display" style="color:var(--highlight-blue)">0</span> üî•
        </div>
        
        <div class="stat-hud-item">
            Accuracy: <span id="stat-accuracy" class="stat-value">--%</span>
        </div>
        <div class="stat-hud-item">
            Avg Speed: <span id="stat-speed" class="stat-value">--s</span>
        </div>
        <button id="replay-btn" style="display:none" onclick="replayTargetTone()">üîä Hear Note</button>
        <button id="next-question" onclick="nextQuestion()">Next Question ‚ûú</button>
        <div id="timer-display" style="display:none;"></div>
        <button id="clear-board-btn" style="display:none" onclick="clearBoardMarkers()">üßπ Clear</button>
    </div>

    <div id="mc-options">
        </div>
    
    <div id="fretboard-wrapper">
        <div id="fretboard-container">
            <div id="fretboard"></div>
        </div>
    </div>

    <div id="cof-wrapper">
        <div class="cof-ring">
            <div id="cof-center-display" class="cof-center">
                Root Note: <span class="cof-center-note" id="cof-root-note"></span>
            </div>
        </div>
    </div>

    <script>
        /* --- UTILITY & AUDIO --- */
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playTone(freq) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(freq, now);
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(2000, now); 
            filter.frequency.exponentialRampToValueAtTime(300, now + 0.2); 
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(0.2, now + 0.02); 
            gain.gain.exponentialRampToValueAtTime(0.0001, now + 1.5); 
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start(now);
            osc.stop(now + 1.5);
        }

        function playBuzzer() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            osc.type = 'square';
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.linearRampToValueAtTime(50, now + 0.5);
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0.5, now);
            gain.gain.exponentialRampToValueAtTime(0.0001, now + 1);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start(now);
            osc.stop(now + 1);
        }

        function calculateFrequency(stringIndex, fret) {
            const openFreq = TUNINGS[currentTuningName][stringIndex];
            return openFreq * Math.pow(2, fret / 12);
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        function clearBoardMarkers() {
            const spots = document.querySelectorAll('.note-spot');
            spots.forEach(s => {
                s.classList.remove('correct', 'incorrect', 'revealed', 'sequence-correct', 'hint-mode-on', 'target-note', 'highlighted-question');
                if(s.getAttribute('data-f') !== '0') {
                    s.textContent = '';
                }
                s.style.pointerEvents = 'auto';
            });
            document.querySelectorAll('.cof-wedge').forEach(w => w.classList.remove('cof-correct', 'cof-incorrect', 'cof-hint'));
            
            document.getElementById('message-display').textContent = "Board Cleared.";
            if (currentMode === 'free') document.getElementById('message-display').textContent = "Click any note to play.";
            
            // Clean up UI
            document.getElementById('mc-options').style.display = 'none';
            document.getElementById('replay-btn').style.display = 'none';
        }

        /* --- DATA --- */
        const NOTES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const NATURAL_NOTES = ["C", "D", "E", "F", "G", "A", "B"];
        const ACCIDENTAL_NOTES = ["C#", "D#", "F#", "G#", "A#"];
        const ANCHOR_FRETS = [0, 3, 5, 7, 9, 12, 15, 17, 19, 21, 24]; // Frets with markers/nut
        const TUNING_INDICES = { 'standard': [4, 11, 7, 2, 9, 4], 'drop_d': [4, 11, 7, 2, 9, 2], 'dadgad': [2, 9, 7, 2, 9, 2], 'open_g': [2, 11, 7, 2, 7, 2] };
        const TUNINGS = { 'standard': [329.63, 246.94, 196.00, 146.83, 110.00, 82.41], 'drop_d': [329.63, 246.94, 196.00, 146.83, 110.00, 73.42], 'dadgad': [293.66, 220.00, 196.00, 146.83, 110.00, 73.42], 'open_g': [293.66, 246.94, 196.00, 146.83, 98.00, 73.42] };
        const CHORD_INTERVALS = { 'Maj': [0, 4, 7], 'Min': [0, 3, 7], '7': [0, 4, 7, 10] };
        const SCALE_INTERVALS = { 'Major': [0, 2, 4, 5, 7, 9, 11], 'Minor': [0, 2, 3, 5, 7, 8, 10] };
        const THEORY = {
            'Maj': "Major Chord: Root + Major 3rd + Perfect 5th. Happy sound.",
            'Min': "Minor Chord: Root + Minor 3rd + Perfect 5th. Sad sound.",
            '7': "Dominant 7th: Major Chord + Minor 7th. Bluesy tension.",
            'MajorScale': "Major Scale: The fundamental Do-Re-Mi pattern.",
            'MinorScale': "Natural Minor Scale: Flattened 3rd, 6th, and 7th.",
            'CoF': "Circle of Fifths: Clockwise moves by Perfect 5ths.",
            'Free': "Free Play: Explore the fretboard sounds.",
            'Single': "Find Note: Locate the named note.",
            'Name': "Name Note: Identify the highlighted note."
        };
        const COF_ORDER = [0, 7, 2, 9, 4, 11, 6, 1, 8, 3, 10, 5];

        /* --- STATE --- */
        let currentTuningName = 'standard';
        let maxFrets = 12; 
        let currentMode = 'free';
        let targetNoteIndex = -1; 
        let targetNotes = []; 
        let baseFret = -1;
        let foundCoordinates = []; 
        let currentSequenceIndex = 0;
        let isQuizActive = false;
        let hintMode = false; 
        let theoryVisible = false;
        let isDarkMode = false;
        let streak = 0;
        const FRET_SPAN = 4;
        
        let currentReplayFreq = 0;
        let timerInterval;
        let timerDuration = 0;
        let startTime; 

        // --- STATS STATE ---
        let totalQuestions = 0;
        let correctAnswers = 0;
        let totalTimeSpent = 0; // in seconds
        
        /* --- STATS FUNCTIONS --- */
        function updateStatsDisplay() {
            const accuracy = totalQuestions > 0 ? ((correctAnswers / totalQuestions) * 100).toFixed(1) : '--';
            const avgSpeed = correctAnswers > 0 ? (totalTimeSpent / correctAnswers).toFixed(1) : '--';
            
            document.getElementById('stat-accuracy').textContent = `${accuracy}%`;
            document.getElementById('stat-speed').textContent = `${avgSpeed}s`;
        }
        
        function resetStats() {
            totalQuestions = 0;
            correctAnswers = 0;
            totalTimeSpent = 0;
            streak = 0;
            document.getElementById('streak-display').textContent = '0';
            updateStatsDisplay();
            document.getElementById('message-display').textContent = "Statistics reset to zero.";
        }
        
        function recordAnswer(isCorrect, timeTaken = 0) {
            // Only record stats for Fretboard Quizzes and Name Note
            if (['single', 'all', 'chord', 'scale', 'name'].includes(currentMode)) {
                totalQuestions++;
                if (isCorrect) {
                    correctAnswers++;
                    totalTimeSpent += timeTaken;
                }
                updateStatsDisplay();
            }
        }

        /* --- LOGIC --- */
        
        function getNote(stringIndex, fret) {
            const openNoteIndex = TUNING_INDICES[currentTuningName][stringIndex];
            return NOTES[(openNoteIndex + fret) % 12];
        }

        function toggleTheme() {
            isDarkMode = !isDarkMode;
            document.body.classList.toggle('dark-mode', isDarkMode);
            document.getElementById('theme-toggle').textContent = isDarkMode ? "‚òÄÔ∏è Light Mode" : "üåô Dark Mode";
        }

        function toggleTheory() {
            theoryVisible = !theoryVisible;
            document.getElementById('theory-panel').style.display = theoryVisible ? 'block' : 'none';
            document.getElementById('theory-toggle').textContent = theoryVisible ? "üìñ Theory: ON" : "üìñ Theory: OFF";
        }

        function toggleHintMode() {
            hintMode = !hintMode;
            document.getElementById('hint-mode-toggle').classList.toggle('active');
            document.getElementById('hint-mode-toggle').textContent = hintMode ? "üí° Hints: ON" : "üí° Hints: OFF";
            (currentMode === 'cof') ? updateCofHints() : updateHints();
        }
        
        function changeSetting() {
            currentTuningName = document.getElementById('tuning-select').value;
            maxFrets = parseInt(document.getElementById('range-select').value);
            timerDuration = parseInt(document.getElementById('timer-select').value);
            stopTimer(); 
            renderFretboard();
            
            const modeToStart = (currentMode === 'free' || currentMode === 'cof') ? 'single' : currentMode;
            if(currentMode !== 'cof' && currentMode !== 'free') startQuiz(modeToStart); 
        }
        
        function resetTimer() {
            timerDuration = parseInt(document.getElementById('timer-select').value);
            if(isQuizActive) startTimer();
        }

        function startTimer() {
            stopTimer();
            if (timerDuration > 0) {
                let timeLeft = timerDuration;
                const timerDisplay = document.getElementById('timer-display');
                timerDisplay.style.display = 'block';
                timerDisplay.textContent = timeLeft;
                
                timerInterval = setInterval(() => {
                    timeLeft--;
                    timerDisplay.textContent = timeLeft;
                    if (timeLeft <= 0) {
                        stopTimer();
                        if (isQuizActive) {
                            playBuzzer();
                            document.getElementById('message-display').textContent = "Time Up! Round Lost.";
                            loseRound();
                        }
                    }
                }, 1000);
            } else {
                document.getElementById('timer-display').style.display = 'none';
            }
        }

        function stopTimer() {
            clearInterval(timerInterval);
            document.getElementById('timer-display').style.display = 'none';
        }

        function updateFilterVisibility(mode) {
            const isNameNote = mode === 'name';
            const isFretboardQuiz = ['single', 'all', 'chord', 'scale'].includes(mode);
            
            // Hide all specialized filters first
            document.getElementById('chord-filters').style.display = 'none';
            document.getElementById('scale-filters').style.display = 'none';
            document.getElementById('name-note-string-filters').style.display = 'none';
            document.getElementById('name-note-type-filters').style.display = 'none';
            
            // Set Timer/Clear button visibility based on mode
            document.getElementById('timer-setting').style.display = isNameNote ? 'flex' : 'none';
            document.getElementById('clear-board-btn').style.display = (isFretboardQuiz || mode === 'free') ? 'block' : 'none';

            // Show relevant filters
            if (isNameNote) {
                document.getElementById('name-note-string-filters').style.display = 'flex';
                document.getElementById('name-note-type-filters').style.display = 'flex';
            } else if (mode === 'chord') {
                document.getElementById('chord-filters').style.display = 'flex';
            } else if (mode === 'scale') {
                document.getElementById('scale-filters').style.display = 'flex';
            }
        }

        function renderFretboard() {
            const board = document.getElementById('fretboard');
            board.innerHTML = '';
            board.style.gridTemplateColumns = `repeat(${maxFrets + 1}, auto)`;

            for (let f = 0; f <= maxFrets; f++) {
                const col = document.createElement('div');
                col.className = f === 0 ? 'nut-column' : 'fret-column';
                col.setAttribute('data-fret', f);

                if (f > 0) {
                    // Anchor Frets logic
                    if ([3, 5, 7, 9, 15, 17, 19, 21].includes(f) && f <= maxFrets) {
                        const m = document.createElement('div'); m.className = 'marker single-marker'; col.appendChild(m);
                    } else if ((f === 12 || f === 24) && f <= maxFrets) {
                        const m1 = document.createElement('div'); m1.className = 'marker double-marker-top'; col.appendChild(m1);
                        const m2 = document.createElement('div'); m2.className = 'marker double-marker-bottom'; col.appendChild(m2);
                    }
                }

                for (let s = 0; s < 6; s++) {
                    const cell = document.createElement('div'); cell.className = 'string-cell';
                    const line = document.createElement('div'); line.className = `string-line string-${s}`; cell.appendChild(line);
                    const spot = document.createElement('div'); spot.className = 'note-spot';
                    spot.setAttribute('data-s', s); spot.setAttribute('data-f', f); spot.setAttribute('data-note', getNote(s, f));
                    if (f === 0) spot.textContent = getNote(s, f);
                    spot.onclick = handleNoteClick;
                    cell.appendChild(spot); col.appendChild(cell);
                }
                board.appendChild(col);
            }
            if(hintMode && currentMode !== 'cof') updateHints();
        }

        function renderCofWheel(rootNote, direction) {
            const ring = document.querySelector('#cof-wrapper .cof-ring');
            // Remove previous wedges
            ring.querySelectorAll('.cof-wedge-container').forEach(c => c.remove()); 

            const rootNoteIndex = NOTES.indexOf(rootNote);
            const targetNoteIndex = (direction === 'Up') ? (rootNoteIndex + 7) % 12 : (rootNoteIndex - 7 + 12) % 12;
            const targetNote = NOTES[targetNoteIndex];

            document.getElementById('cof-root-note').textContent = rootNote;
            
            for (let i = 0; i < 12; i++) {
                const noteIndex = COF_ORDER[i];
                const note = NOTES[noteIndex];
                const container = document.createElement('div'); container.className = 'cof-wedge-container';
                // Rotate container to position the wedge
                container.style.transform = `rotate(${i * 30}deg)`;
                
                const wedge = document.createElement('div'); wedge.className = 'cof-wedge';
                wedge.setAttribute('data-note', note); wedge.onclick = handleCofClick;
                
                const label = document.createElement('div'); label.className = 'cof-note-label'; label.textContent = note;
                
                // Rotation for label placement
                const labelRotation = 30 * i + 15; 
                label.style.transform = `rotate(${labelRotation}deg) translate(140px, -10px)`;
                
                container.appendChild(wedge); 
                container.appendChild(label); 
                ring.appendChild(container);
            }
            // Ensure center is on top
            ring.appendChild(document.getElementById('cof-center-display'));
            targetNotes = [targetNote];
            if (hintMode) updateCofHints();
        }
        
        function updateCofHints() {
            document.querySelectorAll('.cof-wedge').forEach(w => w.classList.remove('cof-hint'));
            if (hintMode && targetNotes.length > 0) {
                const targetWedge = document.querySelector(`.cof-wedge[data-note="${targetNotes[0]}"]`);
                if (targetWedge) targetWedge.classList.add('cof-hint');
            }
        }

        function toggleVisualArea(activeArea) {
            document.getElementById('fretboard-wrapper').style.display = (activeArea === 'fretboard') ? 'flex' : 'none';
            document.getElementById('cof-wrapper').style.display = (activeArea === 'cof') ? 'flex' : 'none';
            clearBoardMarkers(); 
        }

        function getAllValidCoordinates(notesToFind) {
            const validCoords = [];
            const startFret = (baseFret === -1) ? 0 : baseFret;
            const endFret = (baseFret === -1) ? maxFrets : (baseFret + FRET_SPAN - 1);
            for (let s = 0; s < 6; s++) {
                let checkStart = (startFret === 0 || startFret === 1) ? 0 : startFret;
                for (let f = checkStart; f <= endFret; f++) {
                    if (f === 0 && startFret > 1) continue; 
                    if (f > maxFrets) continue;
                    if (notesToFind.includes(getNote(s, f))) validCoords.push([s, f]);
                }
            }
            return validCoords;
        }
        
        function getValidNameNoteCoordinates() {
            const selectedStrings = Array.from(document.querySelectorAll('#name-note-string-filters input:checked')).map(cb => parseInt(cb.getAttribute('data-s')));
            const noteTypeFilter = document.querySelector('input[name="note_type_filter"]:checked').value;
            const validCoords = [];
            
            for (let s of selectedStrings) {
                for (let f = 0; f <= maxFrets; f++) {
                    const note = getNote(s, f);
                    let isNoteTypeValid = false;
                    
                    if (noteTypeFilter === 'all') isNoteTypeValid = true;
                    else if (noteTypeFilter === 'naturals') isNoteTypeValid = NATURAL_NOTES.includes(note);
                    else if (noteTypeFilter === 'accidentals') isNoteTypeValid = ACCIDENTAL_NOTES.includes(note);
                    else if (noteTypeFilter === 'anchors') isNoteTypeValid = ANCHOR_FRETS.includes(f);

                    if (isNoteTypeValid) {
                        validCoords.push([s, f]);
                    }
                }
            }
            return validCoords;
        }


        function generateDistractors(correctNoteIndex) {
            const wrongIndices = NOTES.map((_, i) => i).filter(i => i !== correctNoteIndex);
            const closeIndices = [
                (correctNoteIndex + 1) % 12, (correctNoteIndex + 11) % 12, 
                (correctNoteIndex + 2) % 12, (correctNoteIndex + 10) % 12,
                (correctNoteIndex + 3) % 12, (correctNoteIndex + 9) % 12
            ];
            const uniqueDistractors = new Set();
            for (const index of closeIndices) {
                if (index !== correctNoteIndex) uniqueDistractors.add(NOTES[index]);
                if (uniqueDistractors.size >= 4) break;
            }
            while (uniqueDistractors.size < 4) {
                const randomWrongIndex = wrongIndices[Math.floor(Math.random() * wrongIndices.length)];
                uniqueDistractors.add(NOTES[randomWrongIndex]);
                const idx = wrongIndices.indexOf(randomWrongIndex);
                if (idx > -1) wrongIndices.splice(idx, 1);
            }
            return Array.from(uniqueDistractors);
        }

        function setupMultipleChoice(correctNote) {
            const options = [correctNote, ...generateDistractors(NOTES.indexOf(correctNote))];
            shuffleArray(options);
            const mcOptionsDiv = document.getElementById('mc-options');
            mcOptionsDiv.innerHTML = '';
            
            // KEY FIX: Re-enable pointer events for the new round
            mcOptionsDiv.style.pointerEvents = 'auto'; 

            options.forEach(note => {
                const button = document.createElement('button');
                button.className = 'mc-button';
                button.textContent = note;
                button.setAttribute('data-answer', note);
                button.onclick = handleMcAnswer;
                mcOptionsDiv.appendChild(button);
            });
            mcOptionsDiv.style.display = 'flex';
        }

        function handleMcAnswer(e) {
            const endTime = Date.now();
            const timeTaken = (endTime - startTime) / 1000; // time in seconds
            
            stopTimer(); // Stop timer immediately on answer
            if (!isQuizActive) return;
            const selectedNote = e.currentTarget.getAttribute('data-answer');
            const correctNote = targetNotes[0];
            const isCorrect = selectedNote === correctNote;

            document.querySelectorAll('.mc-button').forEach(btn => {
                btn.onclick = null; // Disable clicks individually
                if (btn.getAttribute('data-answer') === correctNote) btn.classList.add('revealed-answer');
            });

            if (isCorrect) {
                e.currentTarget.classList.add('correct-answer');
                winRound(timeTaken);
            } else {
                e.currentTarget.classList.add('wrong-answer');
                loseRound();
                recordAnswer(false, 0); // Record loss (time not counted)
            }
        }
        
        function replayTargetTone() {
            if (currentReplayFreq) playTone(currentReplayFreq);
        }

        function startQuiz(mode) {
            stopTimer();
            clearBoardMarkers();
            currentMode = mode;
            updateFilterVisibility(mode); // Show/hide relevant settings

            foundCoordinates = [];
            currentSequenceIndex = 0;
            baseFret = -1;
            isQuizActive = (mode !== 'free' && mode !== 'cof');
            targetNoteIndex = Math.floor(Math.random() * 12);
            const rootNote = NOTES[targetNoteIndex];

            // Setup UI Visibility
            document.getElementById('mc-options').style.display = 'none';
            document.getElementById('replay-btn').style.display = 'none';
            
            if (mode === 'free') {
                toggleVisualArea('fretboard');
                document.getElementById('target-note-display').textContent = "Free Play";
                document.getElementById('message-display').textContent = "Click any note to play.";
                document.getElementById('theory-content').textContent = THEORY['Free'];
                return;
            }
            
            if (mode === 'cof') {
                toggleVisualArea('cof');
                isQuizActive = true;
                const direction = Math.random() < 0.5 ? 'Up' : 'Down';
                document.getElementById('target-note-display').textContent = `${rootNote} ‚Æï 5th ${direction}?`;
                document.getElementById('message-display').textContent = "Click the note on the wheel.";
                document.getElementById('theory-content').textContent = THEORY['CoF'];
                renderCofWheel(rootNote, direction); 
                return;
            }
            
            // --- FRETBOARD QUIZ MODES (Single, All, Chord, Scale, Name) ---
            toggleVisualArea('fretboard');
            
            if (mode === 'name') {
                const validCoords = getValidNameNoteCoordinates();
                
                if(validCoords.length === 0) {
                    document.getElementById('target-note-display').textContent = "NO NOTES SELECTED";
                    document.getElementById('message-display').textContent = "Adjust string or note type filters.";
                    isQuizActive = false;
                    return;
                }
                
                const [stringIndex, fret] = validCoords[Math.floor(Math.random() * validCoords.length)];
                const note = getNote(stringIndex, fret);
                
                currentReplayFreq = calculateFrequency(stringIndex, fret);
                targetNotes = [note];
                
                document.getElementById('target-note-display').textContent = "Name This Note";
                document.getElementById('message-display').textContent = "Identify the highlighted note below.";
                document.getElementById('theory-content').textContent = THEORY['Name'];
                document.getElementById('replay-btn').style.display = 'block';

                const spot = document.querySelector(`.note-spot[data-s="${stringIndex}"][data-f="${fret}"]`);
                if (spot) {
                    spot.classList.add('highlighted-question');
                    spot.style.pointerEvents = 'none'; 
                }
                
                playTone(currentReplayFreq);
                setupMultipleChoice(note);
                
                startTime = Date.now(); // Start time tracking
                startTimer(); 
                return;
            }

            // Other Fretboard Quizzes
            if (mode === 'single' || mode === 'all') {
                targetNotes = [rootNote];
                document.getElementById('target-note-display').textContent = rootNote;
                document.getElementById('message-display').textContent = mode === 'single' ? "Find ONE." : "Find ALL.";
                document.getElementById('theory-content').textContent = THEORY['Single'];
            } else if (mode === 'chord') {
                const availableTypes = ['Maj', 'Min', '7'].filter(type => document.getElementById(`chord_${type}`).checked);
                if (availableTypes.length === 0) {
                    document.getElementById('message-display').textContent = "Select at least one Chord Type filter.";
                    isQuizActive = false; return;
                }
                const type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
                targetNotes = CHORD_INTERVALS[type].map(i => NOTES[(targetNoteIndex + i) % 12]);
                const maxStart = maxFrets - FRET_SPAN;
                baseFret = Math.floor(Math.random() * (maxStart + 1));
                document.getElementById('target-note-display').textContent = `${rootNote} ${type}`;
                document.getElementById('message-display').textContent = `Frets ${baseFret} - ${baseFret + 3}`;
                document.getElementById('theory-content').textContent = THEORY[type];
            } else if (mode === 'scale') {
                const scaleType = document.querySelector('input[name="scale_type"]:checked').value;
                targetNotes = SCALE_INTERVALS[scaleType].map(i => NOTES[(targetNoteIndex + i) % 12]);
                const maxStart = maxFrets - FRET_SPAN;
                baseFret = Math.floor(Math.random() * (maxStart + 1));
                document.getElementById('target-note-display').textContent = `${rootNote} ${scaleType}`;
                document.getElementById('message-display').textContent = `Play scale in order (Frets ${baseFret} - ${baseFret + 3})`;
                document.getElementById('theory-content').textContent = THEORY[`${scaleType}Scale`];
            }
            
            startTime = Date.now(); // Start time tracking for fretboard quiz
            updateHints();
        }

        function handleCofClick(e) {
            if (!isQuizActive) return;
            const selectedNote = e.currentTarget.getAttribute('data-note');
            const isCorrect = targetNotes.includes(selectedNote);
            document.querySelectorAll('.cof-wedge').forEach(w => { w.onclick = null; w.classList.remove('cof-hint'); });
            
            if (isCorrect) { e.currentTarget.classList.add('cof-correct'); winRound(); } 
            else { e.currentTarget.classList.add('cof-incorrect'); loseRound(); }
        }

        function handleNoteClick(e) {
            const spot = e.currentTarget;
            const s = parseInt(spot.getAttribute('data-s'));
            const f = parseInt(spot.getAttribute('data-f'));
            const note = spot.getAttribute('data-note');
            playTone(calculateFrequency(s, f));

            if (currentMode === 'free') {
                spot.textContent = note; spot.classList.add('correct');
                setTimeout(() => spot.classList.remove('correct'), 300); return;
            }
            // Name mode answers via MC buttons, ignore clicks here
            if (!isQuizActive || currentMode === 'name') return; 
            
            const endTime = Date.now();
            const timeTaken = (endTime - startTime) / 1000;

            let isCorrect = targetNotes.includes(note);
            let isWindowValid = true;
            if (baseFret !== -1) isWindowValid = (f >= baseFret && f < baseFret + FRET_SPAN) || (baseFret <= 1 && f === 0);
            
            if (currentMode === 'scale') {
                const scaleLength = document.querySelector('input[name="scale_type"]:checked').value === 'Minor' ? 7 : 7;
                isCorrect = (note === targetNotes[currentSequenceIndex % scaleLength] && isWindowValid);
            } else { isCorrect = (targetNotes.includes(note) && isWindowValid); }

            spot.textContent = note;
            if (isCorrect) {
                if (currentMode === 'single') {
                    spot.classList.add('correct'); 
                    winRound(timeTaken);
                    spot.style.pointerEvents = 'none'; // Lock single answer
                } else if (currentMode === 'all') { 
                    foundCoordinates.push(`${s},${f}`);
                    spot.classList.add('correct');
                    if (foundCoordinates.length >= getAllValidCoordinates(targetNotes).length) winRound(timeTaken);
                } else if (currentMode === 'scale') {
                    spot.classList.add('sequence-correct'); currentSequenceIndex++;
                    if (currentSequenceIndex >= 7) winRound(timeTaken);
                }
                // Record answer for fretboard quizzes
                if (currentMode === 'single' || currentMode === 'all' || currentMode === 'scale') {
                    // Only record upon *completion* of a question in 'single' or 'all', or on *each correct click* in 'scale'.
                    // For single/all, winRound handles the final recording. For scale, we record here only for individual notes.
                    // To simplify and ensure single notes are recorded correctly:
                    if (currentMode === 'scale' || currentMode === 'single') {
                       recordAnswer(true, timeTaken);
                    }
                }
            } else { 
                spot.classList.add('incorrect'); 
                loseRound(); 
            }
            
            if (currentMode === 'single') spot.style.pointerEvents = 'none';
        }

        function winRound(timeTaken = 0) {
            stopTimer(); 
            isQuizActive = false; streak++;
            document.getElementById('streak-display').textContent = streak;
            document.getElementById('message-display').textContent = "Success! Click Next.";
            document.getElementById('message-display').style.color = "var(--highlight-blue)";
            
            if (currentMode === 'cof') {
                 const w = document.querySelector(`.cof-wedge[data-note="${targetNotes[0]}"]`);
                 if(w) w.classList.add('cof-correct');
            } else {
                document.querySelectorAll('.note-spot').forEach(s => s.style.pointerEvents = 'none');
                if(currentMode === 'name') {
                    const btn = document.querySelector('.mc-button.revealed-answer');
                    if(btn) { btn.classList.add('correct-answer'); btn.classList.remove('revealed-answer'); }
                }
            }
            
            // Record if it's Name Note or Fretboard Quiz completion
            if (currentMode === 'name' || currentMode === 'single' || currentMode === 'all' || currentMode === 'scale') {
                 // For Name Note and Single, timeTaken is the full duration. For All/Scale, this is just recording success.
                 // We only record the timeTaken here if we haven't already recorded it in handleNoteClick (e.g., for scale mode single clicks)
                 if (currentMode === 'name' || currentMode === 'all') {
                    recordAnswer(true, timeTaken);
                 } else if (currentMode === 'single' && !timeTaken) {
                    // This handles the edge case where the correct spot was already clicked
                    recordAnswer(true, (Date.now() - startTime) / 1000);
                 }
                 // Scale mode completion is a bit messy with individual note clicks, but we rely on the cumulative correct count.
            }

            document.getElementById('mc-options').style.pointerEvents = 'none';
        }

        function loseRound() {
            stopTimer(); 
            isQuizActive = false; streak = 0;
            document.getElementById('streak-display').textContent = streak;
            document.getElementById('message-display').textContent = "Incorrect. Solution revealed.";
            document.getElementById('message-display').style.color = "var(--highlight-orange)";
            
            // Record loss
            if (['single', 'all', 'chord', 'scale', 'name'].includes(currentMode)) {
                 recordAnswer(false, 0);
            }

            if (currentMode === 'cof') {
                const w = document.querySelector(`.cof-wedge[data-note="${targetNotes[0]}"]`);
                if(w) w.classList.add('cof-correct');
            } else if (currentMode === 'name') {
                const btn = document.querySelector('.mc-button.revealed-answer');
                if(btn) { btn.classList.add('correct-answer'); btn.classList.remove('revealed-answer'); }
            } else { revealAnswers(); }
            
            document.getElementById('mc-options').style.pointerEvents = 'none';
        }

        function revealAnswers() {
            const needed = getAllValidCoordinates(targetNotes);
            const spots = document.querySelectorAll('.note-spot');
            spots.forEach(sp => {
                const s = parseInt(sp.getAttribute('data-s'));
                const f = parseInt(sp.getAttribute('data-f'));
                if (needed.some(c => c[0] === s && c[1] === f) && !sp.classList.contains('correct') && !sp.classList.contains('sequence-correct')) {
                    sp.classList.add('revealed'); sp.textContent = sp.getAttribute('data-note');
                }
                sp.style.pointerEvents = 'none';
            });
        }

        function updateHints() {
            const spots = document.querySelectorAll('.note-spot');
            const needed = (isQuizActive && currentMode !== 'free') ? getAllValidCoordinates(targetNotes) : [];
            spots.forEach(sp => {
                if(sp.classList.contains('correct') || sp.classList.contains('incorrect') || sp.classList.contains('revealed') || sp.getAttribute('data-f') === '0' || sp.classList.contains('highlighted-question')) return;
                const s = parseInt(sp.getAttribute('data-s'));
                const f = parseInt(sp.getAttribute('data-f'));
                if (hintMode) {
                    sp.classList.add('hint-mode-on'); sp.textContent = sp.getAttribute('data-note');
                    if(needed.some(c => c[0] === s && c[1] === f)) sp.classList.add('target-note'); else sp.classList.remove('target-note');
                } else {
                    sp.classList.remove('hint-mode-on', 'target-note');
                    if (f !== 0) sp.textContent = '';
                }
            });
        }

        function nextQuestion() {
            // Determine the next mode based on the current mode
            let nextMode = currentMode;
            if (currentMode === 'free') nextMode = 'single';
            
            // Re-render fretboard if necessary
            if(nextMode !== 'cof') renderFretboard(); 
            
            startQuiz(nextMode);
        }

        window.onload = () => {
            document.getElementById('range-select').value = '12'; 
            maxFrets = 12; 
            updateStatsDisplay(); // Initial stats display

            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                isDarkMode = true; document.body.classList.add('dark-mode');
                document.getElementById('theme-toggle').textContent = "‚òÄÔ∏è Light Mode";
            } else { document.getElementById('theme-toggle').textContent = "üåô Dark Mode"; }
            
            // Add listeners to Name Note filters to refresh the quiz if active
            const nameNoteFilters = document.querySelectorAll('#name-note-string-filters input, #name-note-type-filters input');
            nameNoteFilters.forEach(el => {
                el.addEventListener('change', () => {
                    if (currentMode === 'name') {
                        startQuiz('name');
                    }
                });
            });
            
            renderFretboard(); 
            renderCofWheel('C', 'Up'); 
            toggleVisualArea('fretboard'); 
            updateFilterVisibility('free');
        };
    </script>
</body>
</html>
